\documentclass[11pt]{article}
\usepackage{graphicx}    % needed for including graphics e.g. EPS, PS
\topmargin -1.5cm        % read Lamport p.163
\oddsidemargin -0.04cm   % read Lamport p.163
\evensidemargin -0.04cm  % same as oddsidemargin but for left-hand pages
\textwidth 16.59cm
\textheight 21.94cm 
%\pagestyle{empty}       % Uncomment if don't want page numbers
\parskip 7.2pt           % sets spacing between paragraphs
%\renewcommand{\baselinestretch}{1.5} % Uncomment for 1.5 spacing between lines
\parindent 0pt		 % sets leading space for paragraphs

\begin{document}         
% Start your text
\section{Introduction}
\label{Introduction}

In this project,will be use a board, which is a “Vehicle Electronic Speed Controller” (VESC) for a permanent-magnet DC motor (BLDC). This project currently involves the use of an RTOS called ChibiOS and a STM32F405 microprocessor.it would be interesting if using  Miosix instead of ChibiOS, since it will involve not only the porting of Miosix to the board, but also the implementation of the real-time routines for this motor to work correctly, mainly the rotor position with a real-time, time-stamp for a correct performance.

\subsection{The Problem Statement}
\label{problem Statement}

Section~\ref{Introduction} described the article style.  Notice
how Latex lets you use the label name to refer to a whatever
section or sub-section 

\subsection{Summery of the work}
\label{Summery of the work}

Selecting the Project definition and proposal while start to learn more about the Miosix which is an operating system for microcontrollers to 32-bit, designed to execute code C / C ++ on computers with few resources and without memory management units . The project has been in development since 2008, and is known in academia.Miosix will also focus on making it as portable as possible the code written for other architectures on the microcontroller, by making minimal changes. Miosix fact runs a filesystem , thread and a preliminary implementation for the management of processes (despite the limitations imposed by the lack of MMU in microcontrollers), in addition to providing the API for low-level hardware access, also allows you to use the same standard libraries of C or C ++, creating a development environment similar to what you would have in a kind of platform UNIX .
The kernel must be compiled together with their code, so that it can be the linking static with the features offered by the kernel itself or by the standard libraries of C or C ++. Then we start to    Installation of the required software\newline
* Git \newline
* STM32 ST-Link utility software\newline
* Strawberry Perl \newline
* Notepad++ \newline
as the next step installation of the MIOSIX ToolChain and Cloned the source codes with analyzing it has been done .
in the Summery all the trends that happend are:\newline
 1 Project definition and proposal\newline
 2 Started reading Miosix site\newline
 3. Installation of the required software\newline
 * Git\newline
 * STM32 ST-Link utility software\newline
 *Strawberry Perl\newline
 *Notepad++\newline
 4. Installation of the Miosix Toolchain\newline
 5.Cloned Miosix source code and started analyzing it\newline
 6. Started the setup of the Git repository\newline
our second step was :\newline
 2.1Created the Git repository for the project in GitHub:\newline
  https://github.com/SAHARVM/PolimiEmbedded/tree/master/Embedded\newline
 2.2  Configured Netbeans for Windows\newline
 2.3  Opened a clone of Miosix on Netbeans to start working on it and edited it to compile for a stm32f407vg-bitsboard just for reference
  Changed Makefile.inc, miosix-settings.h and main.cpp – The build was successful after these changes.\newline
 2.4  Installed STM32CubeMX to create the custom board configuration files\newline
  Installed the library for STM32F4 devices and created the configuration file for the VESC board\newline
 2.5 Modified Makefile.inc to add the VESC board. Project is not compiling due to the missing configuration of the other files regarding the porting – To be modified and tested in the board next week.\newline
 2.6  Uploaded the files changed files to GitHub as a reference for the first changes to be done for the VESC board.\newline
 then 
  Modified the Makefile.inc file to correctly call the new files created in the previous weeks for the VESC Board\newline
 2.7 Tried to blink a LED based on the GPIOs example codes and it worked successfully.\newline
 2.8   Proceeded with the configuration of the files bsp.cpp and bsp-impl.h for a correct configuration of the pinout of the board.\newline
 2.9  Tried to turn on other GPIOs with success. The initialization code now turns on 2 LEDs, just as demonstration.\newline
 2.10  We are now trying to setup a PWM signal to move a small servomotor in one of the board outputs, once this is working, we can start writing the algorithms to drive the BLDC motor.\newline

\section{Design and Implementation}
\label{Design and Implementation}

\subsection{BLDC MOTOR}
\label{BLDC MOTOR}
As we mentioned above this project is able to use BLDC Motor as a Controller system which it will be have some features which are :\newline
1. The hardware and software is open source .\newline
2. The customization possibilities are almost endless due to the plenty of CPU-resources left.\newline
3.STM32F4 microcontroller.\newline
4.DRV8302 MOSFET driver / buck converter / current shunt amplifier.\newline
5.IRFS7530 MOEFETs (other FETs in the same package also fit).\newline
6. The output is  5v/1A for external electronics from the buck converter integrated on the DRV8302.\newline
7.  The using Voltage is 8V – 60V (Safe for 3S to 12S LiPo).\newline
8.  The Current is  Up to 240A for a couple of seconds or about 50A continuous depending on the temperature and air circulation around the PCB.\newline
9.Sensored and sensorless FOC wich auto-detection of all motor parameters is implemented since FW 2.3.
Firmware based on ChibiOS/RT.\newline
10.The slightly less than 40mm x 60mm as a selected PCB size\newline
11.Current and voltage  measurement on all phases.\newline
12.Regenerative braking.\newline
13.DC motors are also supported.\newline
14.Sensored or sensorless operation.\newline
15.A GUI with lots of configuration parameters\newline
16.Adaptive PWM frequency to get as good ADC measurements as possible.\newline
17.RPM-based phase advance (or timing/field weakening).\newline
18.Good start-up torque in the sensorless mode (and obviously in the sensored mode as well).\newline
19.The motor is used as a tachometer, which is good for odometry on modified RC cars.\newline
20.Duty-cycle control, speed control or current control.\newline
21.Seamless 4-quadrant operation.\newline
22. PPM signal (RC servo), analog, UART, I2C, USB  or CAN-bus as Interface to control the motor.\newline
23.Wireless wii nunchuk (Nyko Kama) control through the I2C port. This is convenient for electric skateboards.\newline
Consumed and regenerated amp-hour and watt-hour counting.\newline
24.Optional PPM signal output. Useful when e.g. controlling an RC car from a raspberry pi or an android device.\newline
25.The USB port uses the modem profile, so an Android device can be connected to the motor controller without rooting. Because of the servo output, the odometry and the extra ADC inputs (that can be used for sensors), this is perfect for modifying an RC car to be controlled from Android (or raspberry pi).\newline
26.Adjustable protection against\newline
*Low input voltage\newline
*High input voltage\newline
*High motor current\newline
*High input current\newline
*High regenerative braking current (separate limits for the motor and the input)\newline
*Rapid duty cycle changes (ramping)\newline
*High RPM (separate limits for each direction).\newline
27.When the current limits are hit, a soft back-off strategy is used while the motor keeps running. If the current becomes way too high, the motor is switched off completely.\newline
28.The RPM limit also has a soft back-off strategy.\newline
29.Commutation works perfectly even when the speed of the motor changes rapidly. This is due to the fact that the magnetic flux is integrated after the zero crossing instead of adding a delay based on the previous speed.\newline
30.When the motor is rotating while the controller is off, the commutations and the direction are tracked. The duty-cycle to get the same speed is also calculated. This is to get a smooth start when the motor is already spinning.\newline
31.All of the hardware is ready for sensorless field-oriented control (FOC). Writing the software is the remaining part. However, I’m not sure if FOC will have many benefits for low inductance high-speed motors besides running a bit quieter. Sensored and sensorless FOC is fully implemented since FW 2.3.\newline

\subsubsection{BLDC  MOTOR HardWare}
\label{BLDC  MOTOR HardWare}
The PCB is designed using KiCad. Have a look at the links under the Resources heading at the top of this page to find all files. Currently I have no assembled PCBs or kits to sell, but you can order bare PCBs from hackvana with these gerber files. Since hackvana got so many orders for my ESC, Mitch wrote a wiki page about how to order VESC boards from him. That makes it super easy to order the PCBs from him.

The components in the BOM can be ordered from mouser.com. Mouser numbers are included in the BOM as well. Make sure to order a bit extra of small capacitors and resistors in case you drop some of them and since the price doesn’t change much at all. Last I ordered, ordering 10 MOSFETs was cheaper than ordering 6 because there is a price break at 10, so have a look at the price breaks as well.

For assembling the PCBs, the following pictures are useful (the latest versions can be found on github):\newline
Here is the schematic of the BLDC Motor \newline
\begin {center}
\includegraphics[scale=0.75]{BLDC motor hardware schematic.png}\newline

\end{center}

Remember to put an electrolytic capacitor close to the ESC on the supply cable. How large it has to be depends on the length and inductance of the battery cables, but I usually use a 2200uF 63V capacitor. \newline

\subsubsection{Software Installation and Configuration}
\label{Software Installation and Configuration}
By following step by step we will be able to start how to get everything running using a fresh install of Ubuntu 14.04. \newline
1.Install a toolchain to compile the firmware :\newline
sudo apt-get remove binutils-arm-none-eabi gcc-arm-none-eabi\newline
sudo add-apt-repository ppa:terry.guo/gcc-arm-embedded\newline
sudo apt-get update\newline
sudo apt-get install gcc-arm-none-eabi=4.9.3.2015q3-1trusty1\newline

2.Install other dependencies\newline
sudo apt-get install build-essential qt-sdk openocd git libudev-dev libqt5serialport5-dev\newline

3.Add yourself to the dialout group to access the USB port of the ESC without being root:\newline
sudo adduser USER dialout\newline

4.Uninstall modemmanager (unless you use it) to avoid a delay every time the ESC is plugged in to the USB port:\newline
sudo apt-get remove modemmanager\newline

5-Add udev rules to access the programmer without being root:\newline
wget vedder.se/Temp/49-stlinkv2.rules\newline
sudo mv 49-stlinkv2.rules /etc/udev/rules.d/\newline
sudo reload udev\newline
Log out and log back in. You should now be ready to compile the firmware, upload the firmware, compile BLDC Tool and run BLDC tool.\newline

6.DOWNLOAD, COMPILE AND UPLOAD THE FIRMWARE\newline
First, connect a programmer as described in this post. Then, download the latest firmware from github, compile and upload it:\newline
mkdir BLDC\newline
cd BLDC\newline
git clone https://github.com/vedderb/bldc.git bldc-firmware\newline
cd bldc-firmware\newline
make upload cd ..\newline
*Note: before running the make upload command, you should open conf-general.h and select which hardware version you are using. It is printed on the PCB. Also, 2015-01-22 I changed the voltage divider resistors to allow up to 60V to be measured by the ADC, so in that case you also have to override VIN-R1 to 39000.0 in conf-general.h.\newline

7.DOWNLOAD, COMPILE AND UPLOAD THE BOOTLOADER\newline
Again, connect a programmer as described in this post. Then, download the latest bootloader from github, compile and upload it:\newline
mkdir BLDC\newline
cd BLDC\newline
git clone https://github.com/vedderb/bldc-bootloader.git bldc-bootloader\newline
cd bldc-bootloader\newline
make upload  cd ..\newline
With the bootloader, BLDC Tool can be used to upgrade the firmware later.\newline

8.DOWNLOAD, COMPILE AND START BLDC TOOL\newline
From the BLDC directory that you created in the previous step, type:\newline
git clone https://github.com/vedderb/bldc-tool.git bldc-tool\newline
cd bldc-tool\newline
qmake -qt=qt5\newline
make ./BLDC-Tool\newline
You should see the following screen:\newline


\begin {center}
\includegraphics[scale=0.75]{fig1.png}\newline

\end{center}

9.Connect the ESC to the USB port of your computer and click “Connect” in BLDC Tool. The lower right corner should now say “Connected”. If you have gotten this far, you should be ready to connect a motor and configure the ESC from BLDC Tool.\newline

Note: If you have more than one usb-modem device in your computer (laptops often have built-in 3g modems), then you have to change ttyACM0 to the port of the ESC. To figure out which ttyACMx port the ESC got, open a terminal and type the following command right after plugging the USB cable in:\newline
 dmesg | tail\newline
BLDC Tool can also be started by going to the bldc-tool directory with a file browser and double-clicking on “BLDC-Tool”.\newline

10.UPDATING TO THE LATEST FIRMWARE\newline
Updating to the latest firmware and the latest version of BLDC Tool is rather simple. From the bldc-firmware directory, type the following commands while the programming cable is connected to the ESC:\newline

git pull\newline
make upload\newline
Note: Updating the firmware will delete the configuration of the ESC. To save it from BLDC Tool, use the “Read configuration” button and then “Save XML”. After updating the firmware, you can restore it with “Load XML” and “Write configuration”.\newline

Also updating BLDC Tool is important and recommended at the same time as updating the firmware. In order to do that, go to the bldc-tool directory and type:\newline

git pull\newline
qmake\newline
make\newline
Now you have the latest version of the firmware and BLDC Tool. Remember to reconfigure the ESC after these changes.\newline

11.Motor Configuration\newline

Note: During the configuration, it is assumed that the USB cable is connected to the ESC and that the lower right corner of BLDC Tool says “Connected”.\newline

The first thing to do in the “Motor Configuration” tab is to click “Read configuration” while the ESC is connected to get the current configuration. After that, click “Load XML” and look for a configuration that is the same as or similar to your motor in the “mc-configurations” folder included with BLDC Tool. If you find exactly your motor, you don’t have to change anything unless you want to tweak some parameters for your application.\newline

Note: Even if you load an XML configuration file, use “Read configuration” first anyway because the XML might not contain all parameters. The missing parameters will become blank and can mess with things. Soon I will make sure that sane default parameters are loaded, but I haven’t done that yet.\newline

12.SENSORLESS MOTOR PARAMETERS\newline
Since this ESC uses uncommon techniques to commutate the motor in order to get good low-speed performance without sensors, it is important to set correct motor-dependent parameters in the sensor(less) tab. Otherwise, the motor will run poorly or not at all.\newline

This is what the Sensor(less) configuration page currently looks like (I will probably add more auto-detect options soon):\newline
\begin {center}
\includegraphics[scale=0.75]{fig2.png}\newline

\end{center}

The important motor-dependent parameters are “Integrator limit” and “BEMF Coupling”, and they can be measured with the detection part. I will make a video showing this for several different motors soon, but until then you can try to follow these instructions:\newline

Connect the motor without any load and make sure that it can spin up freely.\newline
Make sure that no other input such as PPM is used. If it is, it will stop the motor immediately when the detection tries to start it and the detection will fail.\newline
Click the “Start detection” button. The motor should spin up, release throttle and then run slowly for a moment.\newline
If the motor doesn’t spin up properly, Adjust “Current” and “Min ERPM” until it does. In general, small motors should have lower current and higher ERPM and larger motors the other way around. Current usually is in the range 1A to 6A and min ERPM usually is in the range 300 to 1200.\newline
If spinning up works but running slowly afterwards doesn’t (the motor just stutters), try increasing “Low duty” to 0.1 or so.\newline Increasing low duty will make it easier for the motor to run slowly during the test, but the result will become less accurate.\newline
Manually put the obtained values into the boxes. I usually round “integrator limit” down to the closest multiple of 5 and “BEMF Coupling” down to the closest multiple of 50. Having them slightly lower than the detection result is good in most cases, so that’s why I round them downwards like that. Getting these parameters perfectly right is not too critical though.\newline
The next parameters to adjust are “Min ERPM” and “Min ERPM for integrator limit”.\newline
What they should be depends on the application and is in most cases not too important, but in general lowering them will work better if the load has much inertia. I have Min ERPM around 200 and Min ERPM for integrator limit around 1000 for all my applications.\newline
You can probably keep the same parameters I have, but if you want to tweak your startup you can experiment with them.
It is important that “Min ERPM” always is lower than “Max ERPM at full brake” and “Max ERPM at full brake in current control mode” on the “Limits” page.\newline
Commutation mode should always be “Integrate”.\newline
The other parameters are for RPM-based timing advance and some other things that aren’t necessary to adjust in the normal case, so I won’t explain them here yet.\newline
For small low-inductance high-speed motors, the delay commutation mode can be used in case the integrate mode does not work. It does not require many parameters, just the minimum RPM which usually can be around 1500. I haven’t tested this mode much, but it is more or less how most hobby ESCs work (which is why it doesn’t require so many motor-specific parameters). Currently it does not support adjustable timing, but I will implement that in a few days since it is quite easy.\newline

Phase advance (other terms: timing adjustment, field weakening)\newline
To compensate for the current lagging behind the voltage at high speeds because of inductance or to get a bit higher top speed at the expense of some efficiency and torque, phase advance can be used. It is implemented in a speed-dependent way so that the motor gets more phase advance the faster it spins. It is implemented this way because having phase advance at low speeds does not give any improvements at all as far as I know, so the best way is to increase the effect as the motor increases its speed. BR ERPM is the electrical RPM of the motor at which the set phase advance is used, and Integrator limit scale at BR ERPM (will rename this option soon…) is the amount of phase advance to use. Setting it to 1.0 gives no phase advance and setting it to 0.0 gives 30 degrees (maximum) phase advance. The set phase advance will be mapped linearly between 0 ERPM and BR ERPM. If you don’t know what this is, you can leave the default options since it is not that important.\newline

MOTOR
Current, temperature, RPM and voltage-limits can be configured depending on your application.\newline
\begin {center}
\includegraphics[scale=0.75]{fig3.png}\newline

\end{center}

Note: These limits are not foolproof. If you set them too high, you can damage the ESC and/or the motor..\newline

13.Current.\newline
Separate limits for acceleration and braking current..\newline
Separate limits for motor and battery currents..\newline
“Absolute max” is checked in every PWM switching cycle and used in case the soft back-off strategy for the other limits doesn’t work. I usually set it way higher than the other limits because soft back-off is preferred rather than switching off the motor with a fault code, but it should never be higher than 150A..\newline
The “Slow absolute max” box will make sure that a filtered version of the maximum current limit is used. This is useful if there is much noise and that fault code kicks in all the time. I usually have it ticked..\newline
14.Temperature.\newline
At the “Start” temperature, the current will become more and more limited linearly until the “End” temperature, where the output is switched off completely. Setting them about 20 degrees apart will make the ESC slowly decrease the maximum output current as it gets too warm instead of abruptly switching everything off..\newline
MOSFET temps (on the ESC) are implemented and working, but motor temps are not implemented yet. They will require an external temperature sensor in the motor. The software implementation is rather simple since I can just copy most of the MOSFET temperature limit code..\newline
15.RPM.\newline
Max and Min ERPM are hard RPM limits. It is preferable to use the soft application RPM limits instead if possible..\newline
“Max ERPM at full brake” (should change the name…) is the highest opposing RPM at which a direction change is allowed. Setting this too high will cause cogging when moving in one direction and giving high throttle in the other direction. On my longboard I have it at 300 and my RC car has it a bit higher..\newline
“Max ERPM at full brake in CC mode” is the highest RPM at which applying full brake by shorting all the motor windings is allowed. Setting this value too high can cause much mechanical stress in some circumstances. I have it at 1500 for all my applications.\newline.
16.Voltage.\newline
The minimum and maximum input voltage..\newline
NOTE: I changed the voltage dividers in hardware 2015-01-22. If you have built the PCB before that, the maximum voltage can’t be more than 52V. The difference is whether the PCB has 33k or 39k resistors. 33k means that maximum 52V can be measured. The latest PCBs (with 39k resistors) can measure 60V, but you should have some margin on your supply voltage to be safe. You can of course replace all 33k resistors with 39k and measure up to 60V..\newline
Once the ESC is configured for your motor, you can use the up and down arrow keys to run the motor forwards or reverse in current control mote, or the right and left arrow keys to run the motor forwards and reverse in duty cycle mode. The buttons in the right-hand side of the GUI can also be used..\newline

17.MISC.\newline
Here are the rest of the motor configuration parameters. You probably want to experiment with Startup boost if you are using current control. The rest of the parameters can be left as their default values unless you have some specific reason to change them..\newline
\begin {center}
\includegraphics[scale=0.75]{fig4.png}\newline

\end{center}

18.PWM mode\newline
Synchronous is recommended and the best choice for a majority of all motors. If you have some weird motor, Bipolar could work better, but it probably won’t. Nonsynchronous is only for experimentation and can kill the ESC if you are unlucky.\newline

19.Current control\newline
Startup boost is the minimum duty cycle to use when using current control. If the motor is to weak when you are just starting, you can increase this parameter a bit until it feels right. The range is 0.0 to 1.0, where 1.0 is full throttle (which you shouldn’t use.). A sane range is up to 0.15 or so.\newline
Min current is the minimum allowed current. There should be no reason to change this, so leave it at the default value.\newline
Control gain is the gain used by the current controller. Increasing it makes the current response faster, but also increases the risk of getting an unstable system where the ESC can get damaged. Only change this if you know what you are doing.\newline

20.Speed control\newline
The PID parameters for the speed controller. Only change them if you know what you are doing.\newline

21.Timeouts\newline
Fault stop time is the amount of milliseconds that the ESC should be completely switched of when a fault code arises. After that time, it will switch on and try to listen for commands again.\newline
\begin {center}
\includegraphics[scale=0.75]{fig5.png}\newline

\end{center}

\subsubsection{ Application Configuration}
\label {Application Configuration}

First, click “Read configuration” to get the current configuration from the ESC. After that, select which application to use and configure that application.\newline
\begin {center}
\includegraphics[scale=0.75]{fig6.png}\newline

\end{center}
Controller ID is the ID of this VESC. If multiple VESCs are connected over CAN-bus, they must have different IDs\newline.
Send status over CAN has to be enabled to make other VESCs aware of this VESC and some of its current state. It should be enabled for all slave VESCs when connecting multiple VESCs over CAN-bus.\newline
Changing application requires a reboot. There is a button for that. After a reboot, you have to click connect again.\newline
Timeout is the amount of milliseconds after which the motor should be shut off in case the control signal is missing.\newline
“Brake current to use…” can be set to make the motor brake with a certain current when a timeout occurs instead of just releasing it.\newline
 1.PPM

The signal that a normal RC receiver outputs is a PPM signal, so this can be used when connecting an RC receiver to the servo port.\newline
\begin {center}
\includegraphics[scale=0.75]{fig6.png}\newline
\end{center}
1.1Control mode\newline
Disabled: Nothing at all, motor is off.\newline
Current: Torque control. This is what I prefer since it feels most natural. I haven’t seen hobby ESCs that have current control.\newline
Current no reverse: Save as above, but no reverse function. Note that centring the now will give half throttle.\newline
Current no reverse with brake: No reverse, but centre is zero torque. Reversing will brake, but not change motor direction.\newline
Duty cycle: Duty cycle or voltage control. What most hobby ESCs use\newline.
PID speed control: The throttle command is intepreted as a speed set command and closed-loop control is used to maintain that speed. “PID max ERPM” sets what max throttle should be interpreted as.\newline

1.2Settings\newline
Deadband: how much span in the centre of the throttle should be ignored.\newline
Minimum and maximum pulsewidth: The timing interpretation of the PPM signal can be adjusted in case your receiver doesn’t follow the specification or it you have some other reason to change it. Setting “Control mode” to “Disabled” and ticking display decoded PPM value is useful when adjusting these.\newline
Use Median Filter enables a filter that is very useful when there are glitches on the PPM signal. If you have a quadcopter application, you should disable the filter and make sure that there are no glitches since a filter introduces some delay.\newline

1.3Soft RPM limit.\newline
Speed limit that can be used in current control mode. Setting the start and end limits a bit apart will result in a soft torque decay when approaching the speed limit.\newline
Multiple ESCs over CAN can be enabled to connect several VESCs over CAN bus. All VESCs must have different Controller ID and the slave VESCs must have Send status over CAN enabled (see the general tab under app configuration). The slave VESCs don’t need to have any application enabled since they will just be listening for CAN commands. Traction control can also be enabled, which reduces the torque on motors that spin faster than the slowest motor proportional to their speed difference. To connect VESCs over CAN-bus, connect the CANH and CANL signals between them. DO NOT connect 5v and GND because that is likely to cause ground loops which can reset and/or kill the VESCs.\newline

2.NUNCHUK\newline
The Nyko Kama wireless nunchuk can also be used to control the ESC. Note that not all nunchuks for the nintendo wii will work, because they slightly differently.\newline

\begin {center}
\includegraphics[scale=0.75]{fig7.png}\newline

\end{center}

2.1 Control mode\newline
Disabled or current control with or without reverse. If reverse is used, the Z button is used to toggle a direction change.\newline

2.2 Settings\newline
Deadband: The span in the centre of the throttle that should be ignored.\newline
RPM limits: Limit the electrical RPM of the motor. The start value is the point where the torque should start decreasing and the end value is the point where the output will be switched off. Setting them slightly apart will give a soft RPM limit. Setting them very high will disable the RPM limit.\newline
Ramping time constants: How fast the throttle command should be followed, in seconds.\newline

Multiple ESCs over CAN can be enabled to connect several VESCs over CAN bus. All VESCs must have different Controller ID and the slave VESCs must have Send status over CAN enabled (see the general tab under app configuration). The slave VESCs don’t need to have any application enabled since they will just be listening for CAN commands. Traction control can also be enabled, which reduces the torque on motors that spin faster than the slowest motor proportional to their speed difference. To connect VESCs over CAN-bus, connect the CANH and CANL signals between them. DO NOT connect 5v and GND because that is likely to cause ground loops which can reset and/or kill the VESCs.\newline

\subsubsection{BLDC Motor Schematic}
\label{BLDC Motor Schematic}
 In this part we can figure out how each part of the BLDC has been designed.\newline
first of all we can see that totall BLDC system configuration
\begin {center}
\includegraphics[scale=0.5]{fig8.png}\newline
\end{center}
 power MOSFET Design

\begin {center}
\includegraphics[scale=0.5]{fig9.png}\newline
\end{center}

NTC tempreature Sensor
\begin {center}
\includegraphics[scale=0.5]{fig10.png}\newline
\end{center}

CAN BUS transciever
\begin {center}
\includegraphics[scale=0.5]{fig11.png}\newline
\end{center}

 The filters
\begin {center}
\includegraphics[scale=0.5]{fig12.png}\newline
\end{center}

Mcu(Microcontroller Unit)
\begin {center}
\includegraphics[scale=0.5]{fig13.png}\newline
\end{center}

Mosfet Driver
\begin {center}
\includegraphics[scale=0.5]{fig14.png}\newline
\end{center}

\section{Experimental Evalution}
\label{Experimental Evalution}



\subsection{Experimental Step}
\label{Experimental Step}

\subsection{Results}
\label{Results}


\section{Conclusion and Future work}
\label{Conclusion and Future work} 



\begin{thebibliography}{99}
\bibitem{lamport} Lamport, L., {\it LaTeX : A Documentation
 Preparation System User's Guide and Reference Manual}, Addison-Wesley 
 Pub Co., 2nd edition, August 1994.
\end{thebibliography}
 
% Stop your text
\end{document}

